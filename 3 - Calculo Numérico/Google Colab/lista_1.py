# -*- coding: utf-8 -*-
"""Lista 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lDRu1ubTt1E4sq7bICBB72UzIZl-3EPE

Universidade Tecnológica Federal do Paraná  
Professor: Wellington José Corrêa  
Orientando: Enzo Dornelles Italiano  
Cálculo Numérico  
Conversão de Bases e Aritmética de Ponto Flutuante

# Conversão de Base e Aritmética de Ponto Flutuante

Antes de iniciar é preciso rodar uma vez o código do tópico **Códigos.** 

Lembre-se que às vezes, é conveniente clicar logo acima em *open in playground mode*, bem como salvar uma cópia em seu *Google Drive.*

##Códigos
"""

import math
def dectobinDecimal(n):
    n = int(n)
    binario = ""
    while(True):
        binario = binario + str(n%2)
        n = n//2
        if n == 0:
            break
    binario = binario[::-1]
    print(binario)

def dectobinDecimal1(n):
    n = int(n)
    binario = ""
    while(True):
        binario = binario + str(n%2)
        n = n//2
        if n == 0:
            break
    binario = binario[::-1]
    print(binario, end='')

def dectobinFracionario(n):
    n = str(n)
    x = n.split(".")
    dectobinDecimal1(x[0])

    fracionario = ""
    n = "0." + x[1]
    n = float(n)
    while(True):
        n = n * 2
        if(math.floor(n) == 1):
            fracionario = fracionario + "1"
            n = n - 1
        else:
            fracionario = fracionario + "0"
        if(n == 0):
            break
    print("." + fracionario)

def bintodecDecimal(n):
    n = str(n)
    decimal = 0
    n = n[::-1]
    tam = len(n)
    for i in range(tam):
        if n[i] == "1":
            decimal = decimal + 2**i
    print(decimal)

def bintodecDecimal1(n):
    n = str(n)
    decimal = 0
    n = n[::-1]
    tam = len(n)
    for i in range(tam):
        if n[i] == "1":
            decimal = decimal + 2**i
    print(decimal, end="")
    return decimal

def bintodecFracionario(n):
    n = str(n)
    x = n.split(".")
    bintodecDecimal1(x[0])
    
    temp = 0
    tam = len(x[1])
    for i in range (tam):
        if x[1][i] == "1":
            temp = temp + 2 ** -(i+1)
    temp = str(temp)
    fracionario = temp.split(".")
    print("." + fracionario[1])

def dectohex(n):
    n = int(n)
    hexa = ""
    while(True):
        if(n % 16 == 10):
            hexa = hexa + "A"
        elif(n % 16 == 11):
            hexa = hexa + "B"
        elif(n % 16 == 12):
            hexa = hexa + "C"
        elif(n % 16 == 13):
            hexa = hexa + "D"
        elif(n % 16 == 14):
            hexa = hexa + "E"
        elif(n % 16 == 15):
            hexa = hexa + "F"
        else:
            hexa = hexa + str(n%16)
        n = n//16
        if n == 0:
            break
    hexa = hexa[::-1]
    print(hexa)

def dectohex1(n):
    n = int(n)
    hexa = ""
    while(True):
        if(n % 16 == 10):
            hexa = hexa + "A"
        elif(n % 16 == 11):
            hexa = hexa + "B"
        elif(n % 16 == 12):
            hexa = hexa + "C"
        elif(n % 16 == 13):
            hexa = hexa + "D"
        elif(n % 16 == 14):
            hexa = hexa + "E"
        elif(n % 16 == 15):
            hexa = hexa + "F"
        else:
            hexa = hexa + str(n%16)
        n = n//16
        if n == 0:
            break
    hexa = hexa[::-1]
    print(hexa, end="")
    return hexa

def dectohexF(n):
    n = str(n)
    x = n.split(".")
    dectohex1(x[0])
    hexa = ""
    n = "0." + x[1]
    n = float(n)
    while(True):
        n = n * 16
        if(math.floor(n) > 1):
            hexa = hexa + str(math.floor(n))
            n = n - math.floor(n)
        else:
            hexa = hexa + "0"
        if(n == 0):
            break
    hexa = str(hexa)
    print("." + hexa)

def hexstring2int(n):
    decimal = 0
    n = n[::-1]
    tam = len(n)
    for i in range(tam):
        if n[i] == "A":
            decimal = decimal + 10 * 16**i
        elif n[i] == "B":
            decimal = decimal + 11 * 16**i
        elif n[i] == "C":
            decimal = decimal + 12 * 16**i
        elif n[i] == "D":
            decimal = decimal + 13 * 16**i
        elif n[i] == "E":
            decimal = decimal + 14 * 16**i
        elif n[i] == "F":
            decimal = decimal + 15 * 16**i
        else:
            decimal = decimal + int(n[i]) * 16**i
    print(decimal)

def erroAbs(Aex, Aaprox):
    Eabs = Aex - Aaprox
    if Eabs < 0:
        Eabs *= -1
    print(Eabs)

def erroRel(Aex, Aaprox):
    Eabs = Aex - Aaprox
    if Eabs < 0:
        Eabs *= -1
    Erel = Eabs / Aaprox
    print(Erel)

def paraPontoFlut(n):
    i = 0
    while n > 1:
        n *= (10**-1)
        i+=1
    n = float(n)
    return n, i

def trunc(n, p):
    x, c = paraPontoFlut(n)
    c = int(c)
    trunc = ""
    x = str(x)
    for i in range(p+2): # +2 para o código desconsiderar o 0.
        trunc = trunc + x[i]
    trunc = float(trunc)
    trunc = trunc * 10**c
    w, y, z = str(trunc).partition('.')
    x = ".".join([w, z[:p]])
    print(x)

def arred(n, p):
    x, c = paraPontoFlut(n)

    x = round(x, p)
    x = round(x, p)
    x = x * 10**c
    print(x)

from decimal import *
def Represenbin(n):
    s = int(n[0])
    c = 0
    i, j = 1, 10
    while i < 12 and j > -1:
        x = int(n[i])
        c = c + x * (2 ** j)
        i += 1
        j -= 1

    f = 0
    i, j =  12, -1
    while i < 64 and j > -53:
        x = int(n[i])
        f = f + x * (2**j)
        i += 1
        j -= 1

    result = Decimal((-1)**s * 2**(c-1023) * (1+f))
    print(result)

    import math


def truncar(number, digits) -> float:
    stepper = pow(10.0, digits-1)
    return math.trunc(stepper * number) / stepper

def arredondar(number, digits) -> float:
    stepper = pow(10.0, digits-1)
    return round(stepper * number) / stepper

"""## 1. Conversão de Base

### 1.1 Conversão de base decimal para base binária.
a)Parte inteira: usaremos a função dectobinDecimal(n), onde n é o número inteiro na base 10.

Exemplo: Converta o número 42 na base 2.
"""

dectobinDecimal(35)

"""Assim, $42_2$ = 101010

b) Parte decimal: Usaremos a função
dectobinFracionario(n) onde n é o número fracionário na base 10.

Exemplo: Converta o número 8,7 na base 2.
"""

dectobinFracionario(8.7)

"""Portanto, $8,7_2 \approx$ 1000,1011

### 1.2 Conversão de base binária para a base decimal.
Como na seção anterior, dividiremos em duas partes.

a) Parte inteira: Nesta situação usaremos o comando bintodecDecimal(n), de modo que n é o número na base 2.

Exemplo: Converta o número 101010 na base decimal.
"""

bintodecDecimal(101010)

"""Portanto, $101010_{10}$ = 42.

b) Parte fracionária: Agora usaremos a função bintodecFracionario(n), onde n é o número na base 2.

Exemplo: Converta o número 1000,1011 na base decimal.
"""

bintodecFracionario(1000.1011)

"""Portanto, $1000,1011_{10} \approx$  8,7.

### 1.3 Conversão de base decimal para base hexadecimal
a) Parte inteira: Usaremos a função dectohex(n) onde n é o número inteiro na base 10.

Exemplo: Converta o número 16435930 na base hexadecimal.
"""

dectohex(16435930)

"""b) Parte decimal: Usaremos o comando dectohexF(n) onde n é o número fracionário na base 10.

Exemplo: Converta o número 10,75 na base hexadecimal.
"""

dectohexF(10.75)

"""### 1.4 Conversão de base hexadecimal para base decimal
Neste caso, basta usar o comando hexstring2int("n") onde n é o número na base hexadecimal.

Exemplo: Converta o número hexadecimal "FACADA" na base decimal.
"""

hexstring2int("FACADA")

"""## 2. Aritmética de Ponto Flutuante
### 2.1 Erro absoluto e relativo
No que segue, denotaremos o valor exato por $\text{a}_{\text{ex}}$ e  a aproximação de  $\text{a}_{\text{ex}}$ por $\text{a}_{\text{approx}}$.

Usaremos os comandos:

Erro absoluto: `erroAbs(Aex,Aaprox)`

Erro relativo: `erroRel(Aex,Aaprox)`

**Exemplo:** Determine o erro absoluto e o erro relativo na aproximação de $\text{a}_{\text{ex}} =  \sqrt{2}$ por $\text{a}_{\text{approx}} = 1,41$.
"""

erroAbs(math.sqrt(2), 1.41)

erroRel(math.sqrt(2), 1.41)

"""### 2.2 Truncamento e Arredondamento
Para tanto, denotemos por “n” o número a ser digitado e “p” o número de algarismos a ser estabelecido pelo truncamento e arredondamento. Temos os seguintes comandos:

**Truncamento:** truncar(n, p)


**Arredondamento:** arredondar(n, p)

Exemplo: Realize a aritmética de truncamento com cinco algarismos para os números 1,23675 e $\pi.$
"""

truncar(1.23675, 5)

truncar(math.pi,5)

"""Exemplo: Empregue a aritmética de arredondamento com cinco algarismos para os números $\pi$, 3,2365789 e 3,23442323."""

arredondar(math.pi, 5)

arredondar(3.2365789,5)

arredondar(3.234422,5)

"""### 2.3 Representação Numérica de Ponto Flutuante
Pelo padrão IEEE 754 podemos ter uma representação de números fracionários binários bem maior.

A função aqui é Represenbin(n), onde n é o número binário a ser convertido para decimal.

Exemplo: Converta o número 0100000000111011100100010000000000000000000000000000000000000000

"""

Represenbin('0100000000111011100100010000000000000000000000000000000000000000')
# Represenbin('01' + 8*'0' + '11101110010001' + 40*'0')